/* Advent of Code 2018 Day 12 - https://adventofcode.com/2018/day/12

Cellular automata! I cheated on this question a bit, or was lazy. We were given
an initial state and the transformation rules. Because the pattern would grow
and get wider, I didn't know how much space I'd need so I just padded mine with
a bunch of extra room.

For part 1, we had to only run our automata for 20 generations. For part two...
50 billion generations. Instead of writing code to detect that the automata had
stabalized, I just printed out more and more generations until it did, and then
figured out the formula for the score and did the math.

Someone on the subreddit posted rules and an initial state that generated
Sierpinski triangales!

initial state: .................................#.................................

.#... => #
...#. => #

00 ....................................#....................................
01 ...................................#.#...................................
02 ..................................#...#..................................
03 .................................#.#.#.#.................................
04 ................................#.......#................................
05 ...............................#.#.....#.#...............................
06 ..............................#...#...#...#..............................
07 .............................#.#.#.#.#.#.#.#.............................
08 ............................#...............#............................
09 ...........................#.#.............#.#...........................
10 ..........................#...#...........#...#..........................
11 .........................#.#.#.#.........#.#.#.#.........................
12 ........................#.......#.......#.......#........................
13 .......................#.#.....#.#.....#.#.....#.#.......................
14 ......................#...#...#...#...#...#...#...#......................
15 .....................#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.....................
16 ....................#...............................#....................
17 ...................#.#.............................#.#...................
18 ..................#...#...........................#...#..................
19 .................#.#.#.#.........................#.#.#.#.................
20 ................#.......#.......................#.......#................
21 ...............#.#.....#.#.....................#.#.....#.#...............
22 ..............#...#...#...#...................#...#...#...#..............
23 .............#.#.#.#.#.#.#.#.................#.#.#.#.#.#.#.#.............
24 ............#...............#...............#...............#............
25 ...........#.#.............#.#.............#.#.............#.#...........
26 ..........#...#...........#...#...........#...#...........#...#..........
27 .........#.#.#.#.........#.#.#.#.........#.#.#.#.........#.#.#.#.........
28 ........#.......#.......#.......#.......#.......#.......#.......#........
29 .......#.#.....#.#.....#.#.....#.#.....#.#.....#.#.....#.#.....#.#.......
30 ......#...#...#...#...#...#...#...#...#...#...#...#...#...#...#...#......
31 .....#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.....

Cooooooool!

*/

const apply_rules = (rules, ca) => {
    var next_ca = "".padStart(ca.length, ".");
    for (let j = 0; j < ca.length - 5; j++) {
        for (r of rules) {
            if (ca.substr(j, 5) == r.rule)
                next_ca = next_ca.substr(0,j + 2) + r.res + next_ca.substr(j + 3);
        }
    }

    return next_ca;
};

const count_score = (ca, offset) => {
    var score = 0;
    for (let j = 0; j < ca.length; j++)
        score += ca[j] == "#" ? j - offset : 0;

    return score;
}

var fs = require("fs");
const lines = fs.readFileSync("plants_tri.txt").toString().split("\n");

const initial_state = lines[0].substr(15).trim();
rules = lines.slice(2).map(l => {
    return {rule:l.slice(0, 5), res:l.slice(9, 10)};
});

const padding = ".........................";
var ca = "....." + initial_state + padding + "................................................................................................................";

for (let j = 0; j < 131; j ++) {
    ca = apply_rules(rules, ca);
    let a = ca.substr(ca.indexOf('#')).padEnd(ca.length, '.');
    let s = `${ca} ${j + 1} ${ca.split("").filter(c => c == "#").length} ${count_score(ca, 5)}`;
    console.log(s);
}
